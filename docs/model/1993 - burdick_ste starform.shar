# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
#
# Wrapped by Matt Burdick <burdick@hpindl1> on Wed Sep 14 17:56:49 1988
#                Matt Burdick
#                burdic...@hplabs.hp.com <>
#
# This archive contains:
#        accrete.c        display.c        enviro.c        main.c                
#        utils.c                const.h                structs.h        
#

LANG=""; export LANG

echo x - accrete.c
cat >accrete.c <<'@EOF'
/*----------------------------------------------------------------------*/
/*                           BIBLIOGRAPHY                               */
/*  Dole, Stephen H.  "Formation of Planetary Systems by Aggregation:   */
/*      a Computer Simulation"  October 1969,  Rand Corporation Paper   */
/*        P-4226.                                                                */
/*----------------------------------------------------------------------*/

typedef struct dust_bands_record  *dust_pointer;
typedef struct dust_bands_record {
          double inner_edge;
          double outer_edge;
          int dust_present;
          int gas_present;
          dust_pointer next_band;
     } dust_bands;

/* A few variables global to the entire program:                */
extern planet_pointer planet_head;

/* Now for some variables global to the accretion process:      */
int dust_left;
double r_inner, r_outer, reduced_mass, dust_density, cloud_eccentricity;
dust_pointer dust_head;


void set_initial_conditions(inner_limit_of_dust, outer_limit_of_dust)
double inner_limit_of_dust, outer_limit_of_dust;
{
     dust_head = (dust_bands *)malloc(sizeof(dust_bands));
     planet_head = NULL;
     dust_head->next_band = NULL;
     dust_head->outer_edge = outer_limit_of_dust;
     dust_head->inner_edge = inner_limit_of_dust;
     dust_head->dust_present = TRUE;
     dust_head->gas_present = TRUE;
     dust_left = TRUE;
     cloud_eccentricity = 0.2;
}

double stellar_dust_limit(stellar_mass_ratio)
double stellar_mass_ratio;
{
     return(200.0 * pow(stellar_mass_ratio,(1.0 / 3.0)));
}

double innermost_planet(stellar_mass_ratio)
double stellar_mass_ratio;
{
     return(0.3 * pow(stellar_mass_ratio,(1.0 / 3.0)));
}

double outermost_planet(stellar_mass_ratio)
double stellar_mass_ratio;
{
     return(50.0 * pow(stellar_mass_ratio,(1.0 / 3.0)));
}

double inner_effect_limit(a, e, mass)
double a, e, mass;
{
     return (a * (1.0 - e) * (1.0 - mass) / (1.0 + cloud_eccentricity));
}

double outer_effect_limit(a, e, mass)
double a, e, mass;
{
     return (a * (1.0 + e) * (1.0 + reduced_mass) / (1.0 - cloud_eccentricity));
}

int dust_available(inside_range, outside_range)
double inside_range, outside_range;
{
     dust_pointer current_dust_band;
     int dust_here;
     
     current_dust_band = dust_head;
     while ((current_dust_band != NULL)
            && (current_dust_band->outer_edge < inside_range))
          current_dust_band = current_dust_band->next_band;
     if (current_dust_band == NULL)
          dust_here = FALSE;
     else dust_here = current_dust_band->dust_present;
     while ((current_dust_band != NULL)
            && (current_dust_band->inner_edge < outside_range)) {
               dust_here = dust_here || current_dust_band->dust_present;
               current_dust_band = current_dust_band->next_band;
          }
     return(dust_here);
}

void update_dust_lanes(min, max, mass, crit_mass,
                       body_inner_bound, body_outer_bound)
double min, max, mass, crit_mass, body_inner_bound, body_outer_bound;
{
     int gas;
     dust_pointer node1, node2, node3;
     
     dust_left = FALSE;
     if ((mass > crit_mass))
          gas = FALSE;
     else
          gas = TRUE;
     node1 = dust_head;
     while ((node1 != NULL))
     {
          if (((node1->inner_edge < min) && (node1->outer_edge > max)))
          {
               node2 = (dust_bands *)malloc(sizeof(dust_bands));
               node2->inner_edge = min;
               node2->outer_edge = max;
               if ((node1->gas_present == TRUE))
                    node2->gas_present = gas;
               else
                    node2->gas_present = FALSE;
               node2->dust_present = FALSE;
               node3 = (dust_bands *)malloc(sizeof(dust_bands));
               node3->inner_edge = max;
               node3->outer_edge = node1->outer_edge;
               node3->gas_present = node1->gas_present;
               node3->dust_present = node1->dust_present;
               node3->next_band = node1->next_band;
               node1->next_band = node2;
               node2->next_band = node3;
               node1->outer_edge = min;
               node1 = node3->next_band;
          }
          else
               if (((node1->inner_edge < max) && (node1->outer_edge > max)))
               {
                    node2 = (dust_bands *)malloc(sizeof(dust_bands));
                    node2->next_band = node1->next_band;
                    node2->dust_present = node1->dust_present;
                    node2->gas_present = node1->gas_present;
                    node2->outer_edge = node1->outer_edge;
                    node2->inner_edge = max;
                    node1->next_band = node2;
                    node1->outer_edge = max;
                    if ((node1->gas_present == TRUE))
                         node1->gas_present = gas;
                    else
                         node1->gas_present = FALSE;
                    node1->dust_present = FALSE;
                    node1 = node2->next_band;
               }
               else
                    if (((node1->inner_edge < min) && (node1->outer_edge > min)))
                    {
                         node2 = (dust_bands *)malloc(sizeof(dust_bands));
                         node2->next_band = node1->next_band;
                         node2->dust_present = FALSE;
                         if ((node1->gas_present == TRUE))
                              node2->gas_present = gas;
                         else
                              node2->gas_present = FALSE;
                         node2->outer_edge = node1->outer_edge;
                         node2->inner_edge = min;
                         node1->next_band = node2;
                         node1->outer_edge = min;
                         node1 = node2->next_band;
                    }
                    else
                         if (((node1->inner_edge >= min) && (node1->outer_edge <= max)))
                         {
                              if ((node1->gas_present == TRUE))
                                   node1->gas_present = gas;
                              node1->dust_present = FALSE;
                              node1 = node1->next_band;
                         }
                         else
                              if (((node1->outer_edge < min) || (node1->inner_edge > max)))
                                   node1 = node1->next_band;
     }
     node1 = dust_head;
     while ((node1 != NULL))
     {
          if (((node1->dust_present)
               && (((node1->outer_edge >= body_inner_bound)
                    && (node1->inner_edge <= body_outer_bound)))))
               dust_left = TRUE;
          node2 = node1->next_band;
          if ((node2 != NULL))
          {
               if (((node1->dust_present == node2->dust_present)
                    && (node1->gas_present == node2->gas_present)))
               {
                    node1->outer_edge = node2->outer_edge;
                    node1->next_band = node2->next_band;
                    free(node2);
               }
          }
          node1 = node1->next_band;
     }
}

double collect_dust(last_mass, a, e, crit_mass, dust_band)
double last_mass, a, e, crit_mass;
dust_pointer dust_band;
{
     double mass_density, temp1, temp2, temp, temp_density, bandwidth, width, volume;
     
     temp = last_mass / (1.0 + last_mass);
     reduced_mass = pow(temp,(1.0 / 4.0));
     r_inner = inner_effect_limit(a, e, reduced_mass);
     r_outer = outer_effect_limit(a, e, reduced_mass);
     if ((r_inner < 0.0))
          r_inner = 0.0;
     if ((dust_band == NULL))
          return(0.0);
     else
     {
          if ((dust_band->dust_present == FALSE))
               temp_density = 0.0;
          else
               temp_density = dust_density;
          if (((last_mass < crit_mass) || (dust_band->gas_present == FALSE)))
               mass_density = temp_density;
          else
               mass_density = K * temp_density / (1.0 + sqrt(crit_mass / last_mass)
                                                  * (K - 1.0));
          if (((dust_band->outer_edge <= r_inner)
               || (dust_band->inner_edge >= r_outer)))
               return(collect_dust(last_mass,a,e,crit_mass, dust_band->next_band));
          else
          {
               bandwidth = (r_outer - r_inner);
               temp1 = r_outer - dust_band->outer_edge;
               if (temp1 < 0.0)
                    temp1 = 0.0;
               width = bandwidth - temp1;
               temp2 = dust_band->inner_edge - r_inner;
               if (temp2 < 0.0)
                    temp2 = 0.0;
               width = width - temp2;
               temp = 4.0 * PI * pow(a,2.0) * reduced_mass
                    * (1.0 - e * (temp1 - temp2) / bandwidth);
               volume = temp * width;
               return(volume * mass_density
                      + collect_dust(last_mass,a,e,crit_mass,
                                     dust_band->next_band));
          }
     }
}


/*--------------------------------------------------------------------------*/
/*   Orbital radius is in AU, eccentricity is unitless, and the stellar     */
/*  luminosity ratio is with respect to the sun.  The value returned is the */
/*  mass at which the planet begins to accrete gas as well as dust, and is  */
/*  in units of solar masses.                                               */
/*--------------------------------------------------------------------------*/

double critical_limit(orbital_radius, eccentricity, stellar_luminosity_ratio)
double orbital_radius, eccentricity, stellar_luminosity_ratio;
{
     double temp, perihelion_dist;
     
     perihelion_dist = (orbital_radius - orbital_radius * eccentricity);
     temp = perihelion_dist * sqrt(stellar_luminosity_ratio);
     return(B * pow(temp,-0.75));
}



void accrete_dust(seed_mass, a, e, crit_mass,
                  body_inner_bound, body_outer_bound)
double *seed_mass, a, e, crit_mass,
     body_inner_bound, body_outer_bound;
{
     double perihelion_dist, new_mass, temp_mass;
     
     new_mass = (*seed_mass);
     do
     {
          temp_mass = new_mass;
          new_mass = collect_dust(new_mass,a,e,crit_mass,
                                  dust_head);
     }
     while (!(((new_mass - temp_mass) < (0.0001 * temp_mass))));
     (*seed_mass) = (*seed_mass) + new_mass;
     update_dust_lanes(r_inner,r_outer,(*seed_mass),crit_mass,body_inner_bound,body_outer_bound);
}



void coalesce_planetesimals(a, e, mass, crit_mass,
                            stellar_luminosity_ratio,
                            body_inner_bound, body_outer_bound)
double a, e, mass, crit_mass, stellar_luminosity_ratio,
     body_inner_bound, body_outer_bound;
{
     planet_pointer node1, node2, node3;
     int coalesced;
     double temp, dist1, dist2, a3;
     
     coalesced = FALSE;
     node1 = planet_head;
     while ((node1 != NULL))
     {
          node2 = node1;
          temp = node1->a - a;
          if ((temp > 0.0))
          {
               dist1 = (a * (1.0 + e) * (1.0 + reduced_mass)) - a;
               /* x aphelion   */
               reduced_mass = pow((node1->mass / (1.0 + node1->mass)),(1.0 / 4.0));
               dist2 = node1->a
                    - (node1->a * (1.0 - node1->e) * (1.0 - reduced_mass));
          }
          else
          {
               dist1 = a - (a * (1.0 - e) * (1.0 - reduced_mass));
               /* x perihelion */
               reduced_mass = pow(node1->mass / (1.0 + node1->mass),(1.0 / 4.0));
               dist2 = (node1->a * (1.0 + node1->e) * (1.0 + reduced_mass))
                    - node1->a;
          }
          if (((fabs(temp) <= fabs(dist1)) || (fabs(temp) <= fabs(dist2))))
          {
#ifdef VERBOSE
               printf("Collision between two planetesimals!\n");
#endif
               a3 = (node1->mass + mass) / ((node1->mass / node1->a) + (mass / a));
               temp = node1->mass * sqrt(node1->a) * sqrt(1.0 - pow(node1->e,2.0));
               temp = temp + (mass * sqrt(a) * sqrt(sqrt(1.0 - pow(e,2.0))));
               temp = temp / ((node1->mass + mass) * sqrt(a3));
               temp = 1.0 - pow(temp,2.0);
               if (((temp < 0.0) || (temp >= 1.0)))
                    temp = 0.0;
               e = sqrt(temp);
               temp = node1->mass + mass;
               accrete_dust(&(temp),a3,e,stellar_luminosity_ratio,
                            body_inner_bound,body_outer_bound);
               node1->a = a3;
               node1->e = e;
               node1->mass = temp;
               node1 = NULL;
               coalesced = TRUE;
          }
          else
               node1 = node1->next_planet;
     }
     if (!(coalesced))
     {
          node3 = (planets *)malloc(sizeof(planets));
          node3->a = a;
          node3->e = e;
          if ((mass >= crit_mass))
               node3->gas_giant = TRUE;
          else
               node3->gas_giant = FALSE;
          node3->mass = mass;
          if ((planet_head == NULL))
          {
               planet_head = node3;
               node3->next_planet = NULL;
          }
          else
          {
               node1 = planet_head;
               if ((a < node1->a))
               {
                    node3->next_planet = node1;
                    planet_head = node3;
               }
               else
                    if ((planet_head->next_planet == NULL))
                    {
                         planet_head->next_planet = node3;
                         node3->next_planet = NULL;
                    }
                    else
                    {
                         while (((node1 != NULL) && (node1->a < a)))
                         {
                              node2 = node1;
                              node1 = node1->next_planet;
                         }
                         node3->next_planet = node1;
                         node2->next_planet = node3;
                    }
          }
     }
}


planet_pointer distribute_planetary_masses(stellar_mass_ratio,
                                           stellar_luminosity_ratio, inner_dust, outer_dust)
double stellar_mass_ratio, stellar_luminosity_ratio, inner_dust, outer_dust;
{
     double a, e, mass, crit_mass,
     planetesimal_inner_bound, planetesimal_outer_bound;
     
     set_initial_conditions(inner_dust,outer_dust);
     planetesimal_inner_bound = innermost_planet(stellar_mass_ratio);
     planetesimal_outer_bound = outermost_planet(stellar_mass_ratio);
     while (dust_left)
     {
          a = random_number(planetesimal_inner_bound,planetesimal_outer_bound);
          e = random_eccentricity( );
          mass = PROTOPLANET_MASS;
#ifdef VERBOSE
          printf("Checking %f AU.\n",a);
#endif
          if (dust_available(inner_effect_limit(a, e, mass),
                             outer_effect_limit(a, e, mass))) {
#ifdef VERBOSE
                    printf(".. Injecting protoplanet.\n");
#endif
                    dust_density = DUST_DENSITY_COEFF * sqrt(stellar_mass_ratio)
                         * exp(-ALPHA * pow(a,(1.0 / N)));
                    crit_mass = critical_limit(a,e,stellar_luminosity_ratio);
                    accrete_dust(&(mass),a,e,crit_mass,
                                 planetesimal_inner_bound,
                                 planetesimal_outer_bound);
                    if ((mass != 0.0) && (mass != PROTOPLANET_MASS))
                         coalesce_planetesimals(a,e,mass,crit_mass,
                                                stellar_luminosity_ratio,
                                                planetesimal_inner_bound,planetesimal_outer_bound);
#ifdef VERBOSE
                    else printf(".. failed due to large neighbor.\n");
#endif
               }
#ifdef VERBOSE
          else printf(".. failed.\n");
#endif
     }
     return(planet_head);
}



planet_pointer distribute_moon_masses(planetary_mass, stellar_luminosity_ratio,
                                      planet_eccentricity, inner_dust, outer_dust)
double planetary_mass, stellar_luminosity_ratio, planet_eccentricity,
     inner_dust, outer_dust;
{
     double a, e, mass, crit_mass,
     planetesimal_inner_bound, planetesimal_outer_bound;
     
     return(NULL);
}
@EOF

chmod 644 accrete.c

echo x - display.c
cat >display.c <<'@EOF'
void display_system()
{
     planet_pointer node1;
     int counter;
     char word[(10)+1];
     
     printf("                         SYSTEM  CHARACTERISTICS\n");
     printf("Mass of central star (in solar masses): %4.2lf\n", stellar_mass_ratio);
     printf("Luminosity of central star (relative to the sun): %5.2lf\n",stellar_luminosity_ratio);
     printf("Total main sequence lifetime (in million yrs): %10.3lf\n", (main_seq_life / 1.0E6));
     printf("Current age of stellar system (in million yrs): %10.3lf\n",(age / 1.0E6));
     printf("Radius of habitable ecosphere (AU): %3.3lf\n",r_ecosphere);
     node1 = planet_head;
     counter = 1;
     while (node1 != NULL)
     {
          printf("Planet #%d:\n",counter);
          if (node1->gas_giant)
               printf("Gas giant...\n");
          if (node1->resonant_period)
               printf("In resonant period with primary.\n");
          printf("   Distance from primary star (in A.U.): %7.3lf\n",node1->a);
          printf("   Eccentricity of orbit: %5.3lf\n",node1->e);
          printf("   Mass (in Earth masses): %7.3lf\n",node1->mass * EARTH_MASSES_PER_SOLAR_MASS);
          printf("   Equatorial radius (in Km): %10.1lf\n",node1->radius);
          printf("   Density (in g/cc): %6.3lf\n",node1->density);
          printf("   Escape Velocity (in km/sec): %5.2lf\n",node1->escape_velocity / CM_PER_KM);
          printf("   Smallest molecular weight retained: %5.2lf\n",node1->molecule_weight);
          printf("   Surface acceleration (in cm/sec2): %6.2lf\n",node1->surface_accel);
          if (!(node1->gas_giant))
          {
               printf("   Surface Gravity (in Earth gees): %5.2lf\n",node1->surface_grav);
               printf("   Boiling point of water (celcius): %4.1lf\n",(node1->boil_point - KELVIN_CELCIUS_DIFFERENCE));
               printf("   Surface Pressure (in atmospheres): %5.3lf",(node1->surface_pressure / 1000.0));
               if ((node1->greenhouse_effect) && (node1->surface_pressure > 0.0))
                    printf("     RUNAWAY GREENHOUSE EFFECT\n");
               else
                    printf("\n");
               printf("   Surface temperature (Celcius): %4.2lf\n",(node1->surface_temp - KELVIN_CELCIUS_DIFFERENCE));
               printf("   Hydrosphere percentage: %6.2lf\n",(node1->hydrosphere * 100.0));
               printf("   Cloud cover percentage: %6.2lf\n",(node1->cloud_cover * 100));
               printf("   Ice cover percentage: %6.2lf\n",(node1->ice_cover * 100));
          }
          printf("   Axial tilt (in degrees): %d\n",node1->axial_tilt);
          printf("   Planetary albedo: %4.3lf\n",node1->albedo);
          printf("   Length of year (in days): %7.2lf\n",node1->orbital_period);
          printf("   Length of day (in hours): %7.2lf\n",node1->day);
          counter++;
          node1 = node1->next_planet;
     }
}
@EOF

chmod 644 display.c

echo x - enviro.c
cat >enviro.c <<'@EOF'
double luminosity(mass_ratio)
double mass_ratio;
{
     double n;
     
     if (mass_ratio < 1.0)
          n = 1.75 * (mass_ratio - 0.1) + 3.325;
     else
          n = 0.5 * (2.0 - mass_ratio) + 4.4;
     return(pow(mass_ratio,n));
}


/*--------------------------------------------------------------------------*/
/*   This function, given the orbital radius of a planet in AU, returns     */
/*   the orbital 'zone' of the particle.                                    */
/*--------------------------------------------------------------------------*/

int orbital_zone(orbital_radius)
double orbital_radius;
{
     if (orbital_radius < (4.0 * sqrt(stellar_luminosity_ratio)))
          return(1);
     else
     {
          if ((orbital_radius >= (4.0 * sqrt(stellar_luminosity_ratio))) && (orbital_radius < (15.0 * sqrt(stellar_luminosity_ratio))))
               return(2);
          else
               return(3);
     }
}


/*--------------------------------------------------------------------------*/
/*   The mass is in units of solar masses, and the density is in units      */
/*   of grams/cc.  The radius returned is in units of km.                   */
/*--------------------------------------------------------------------------*/

double volume_radius(mass, density)
double mass, density;
{
     double volume;
     
     mass = mass * SOLAR_MASS_IN_GRAMS;
     volume = mass / density;
     return(pow((3.0 * volume) / (4.0 * PI),(1.0 / 3.0)) / CM_PER_KM);
}

/*--------------------------------------------------------------------------*/
/*    Returns the radius of the planet in kilometers.                       */
/*   The mass passed in is in units of solar masses, the orbital radius     */
/*   in A.U.                                                                */
/*   This formula is listed as eq.9 in Fogg's article, although some typos  */
/*   crop up in that eq.  See "The Internal Constitution of Planets", by    */
/*   Dr. D. S. Kothari, Mon. Not. of the Royal Astronomical Society, vol 96 */
/*   pp.833-843, 1936 for the derivation.  Specifically, this is Kothari's  */
/*   eq.23, which appears on page 840.                                      */
/*--------------------------------------------------------------------------*/

double kothari_radius(mass, orbital_radius, giant, zone)
double mass, orbital_radius;
int giant, zone;
{
     double temp, temp2, atomic_weight, atomic_num;
     
     if (zone == 1)
     {
          if (giant)
          {
               atomic_weight = 9.5;
               atomic_num = 4.5;
          }
          else
          {
               atomic_weight = 15.0;
               atomic_num = 8.0;
          }
     }
     else
          if (zone == 2)
          {
               if (giant)
               {
                    atomic_weight = 2.47;
                    atomic_num = 2.0;
               }
               else
               {
                    atomic_weight = 10.0;
                    atomic_num = 5.0;
               }
          }
          else
          {
               if (giant)
               {
                    atomic_weight = 7.0;
                    atomic_num = 4.0;
               }
               else
               {
                    atomic_weight = 10.0;
                    atomic_num = 5.0;
               }
          }
     temp = atomic_weight * atomic_num;
     temp = (2.0 * BETA_20 * pow(SOLAR_MASS_IN_GRAMS,(1.0 / 3.0))) / (A1_20 * pow(temp,(1.0 / 3.0)));
     temp2 = A2_20 * pow(atomic_weight,(4.0 / 3.0)) * pow(SOLAR_MASS_IN_GRAMS,(2.0 / 3.0));
     temp2 = temp2 * pow(mass,(2.0 / 3.0));
     temp2 = temp2 / (A1_20 * pow(atomic_num, 2.0));
     temp2 = 1.0 + temp2;
     temp = temp / temp2;
     temp = (temp * pow(mass,(1.0 / 3.0))) / CM_PER_KM;
     return(temp);
}


/*--------------------------------------------------------------------------*/
/*  The mass passed in is in units of solar masses, and the orbital radius  */
/*  is in units of AU.  The density is returned in units of grams/cc.       */
/*--------------------------------------------------------------------------*/

double empirical_density(mass, orbital_radius, gas_giant)
double mass, orbital_radius;
int gas_giant;
{
     double temp;
     
     temp = pow(mass * EARTH_MASSES_PER_SOLAR_MASS,(1.0 / 8.0));
     temp = temp * pow(r_ecosphere / orbital_radius,(1.0 / 4.0));
     if (gas_giant)
          return(temp * 1.2);
     else
          return(temp * 5.5);
}


/*--------------------------------------------------------------------------*/
/*  The mass passed in is in units of solar masses, and the equatorial      */
/*  radius is in km.  The density is returned in units of grams/cc.         */
/*--------------------------------------------------------------------------*/

double volume_density(mass, equatorial_radius)
double mass, equatorial_radius;
{
     double volume;
     
     mass = mass * SOLAR_MASS_IN_GRAMS;
     equatorial_radius = equatorial_radius * CM_PER_KM;
     volume = (4.0 * PI * pow(equatorial_radius,3.0)) / 3.0;
     return(mass / volume);
}


/*--------------------------------------------------------------------------*/
/*  The separation is in units of AU, and both masses are in units of solar */
/*  masses.  The period returned is in terms of Earth days.                 */
/*--------------------------------------------------------------------------*/

double period(separation, small_mass, large_mass)
double separation, small_mass, large_mass;
{
     double period_in_years;
     
     period_in_years = sqrt(pow(separation,3.0) / (small_mass + large_mass));
     return(period_in_years * DAYS_IN_A_YEAR);
}


/*--------------------------------------------------------------------------*/
/*   Fogg's information for this routine came from Dole "Habitable Planets  */
/* for Man", Blaisdell Publishing Company, NY, 1964.  From this, he came    */
/* up with his eq.12, which is the equation for the base_angular_velocity   */
/* below.  Going a bit further, he found an equation for the change in      */
/* angular velocity per time (dw/dt) from P. Goldreich and S. Soter's paper */
/* "Q in the Solar System" in Icarus, vol 5, pp.375-389 (1966).  Comparing  */
/* to the change in angular velocity for the Earth, we can come up with an  */
/* approximation for our new planet (his eq.13) and take that into account. */
/*--------------------------------------------------------------------------*/

double day_length(mass, radius, orbital_period, eccentricity, giant)
double mass, radius, orbital_period, eccentricity;
int giant;
{
     double base_angular_velocity, planetary_mass_in_grams, k2, temp,
     equatorial_radius_in_cm, change_in_angular_velocity, spin_resonance_period;
     
     spin_resonance = FALSE;
     if (giant)
          k2 = 0.24;
     else
          k2 = 0.33;
     planetary_mass_in_grams = mass * SOLAR_MASS_IN_GRAMS;
     equatorial_radius_in_cm = radius * CM_PER_KM;
     base_angular_velocity = sqrt(2.0 * J * (planetary_mass_in_grams) / (k2 * pow(equatorial_radius_in_cm, 2.0)));
     /*   This next term describes how much a planet's rotation is slowed by    */
     /*  it's moons.  Find out what dw/dt is after figuring out Goldreich and   */
     /*  Soter's Q'.                                                            */
     change_in_angular_velocity = 0.0;
     temp = base_angular_velocity + (change_in_angular_velocity * age);
     /*   'temp' is now the angular velocity. Now we change from rad/sec to     */
     /*  hours/rotation.                                                           */
     temp = 1.0 / ((temp / radians_per_rotation) * SECONDS_PER_HOUR);
     if (temp >= orbital_period)
     {
          spin_resonance_period = ((1.0 - eccentricity) / (1.0 + eccentricity)) * orbital_period;
          if (eccentricity > 0.1)
          {
               temp = spin_resonance_period;
               spin_resonance = TRUE;
          }
          else
               temp = orbital_period;
     }
     return(temp);
}


/*--------------------------------------------------------------------------*/
/*   The orbital radius is expected in units of Astronomical Units (AU).    */
/*   Inclination is returned in units of degrees.                           */
/*--------------------------------------------------------------------------*/

int inclination(orbital_radius)
double orbital_radius;
{
     int temp;
     
     temp = (int)(pow(orbital_radius,0.2) * about(EARTH_AXIAL_TILT,0.4));
     return(temp % 360);
}


/*--------------------------------------------------------------------------*/
/*   This function implements the escape velocity calculation.  Note that   */
/*  it appears that Fogg's eq.15 is incorrect.                              */
/*  The mass is in units of solar mass, the radius in kilometers, and the   */
/*  velocity returned is in cm/sec.                                         */
/*--------------------------------------------------------------------------*/

double escape_vel(mass, radius)
double mass, radius;
{
     double mass_in_grams, radius_in_cm;
     
     mass_in_grams = mass * SOLAR_MASS_IN_GRAMS;
     radius_in_cm = radius * CM_PER_KM;
     return(sqrt(2.0 * GRAV_CONSTANT * mass_in_grams / radius_in_cm));
}


/*--------------------------------------------------------------------------*/
/*  This is Fogg's eq.16.  The molecular weight (usually assumed to be N2)  */
/*  is used as the basis of the Root Mean Square velocity of the molecule   */
/*  or atom.  The velocity returned is in cm/sec.                           */
/*--------------------------------------------------------------------------*/

double rms_vel(molecular_weight, orbital_radius)
double molecular_weight, orbital_radius;
{
     double exospheric_temp;
     
     exospheric_temp = EARTH_EXOSPHERE_TEMP / pow(orbital_radius, 2.0);
     return(sqrt((3.0 * MOLAR_GAS_CONST * exospheric_temp) / molecular_weight) * CM_PER_METER);
}


/*--------------------------------------------------------------------------*/
/*   This function returns the smallest molecular weight retained by the    */
/*  body, which is useful for determining the atmosphere composition.       */
/*  Orbital radius is in A.U.(ie: in units of the earth's orbital radius),  *)
    (*  mass is in units of solar masses, and equatorial radius is in units of  */
/*  kilometers.                                                             */
/*--------------------------------------------------------------------------*/

double molecule_limit(orbital_radius, mass, equatorial_radius)
double orbital_radius, mass, equatorial_radius;
{
     double numerator, denominator1, denominator2, escape_velocity, temp;
     
     escape_velocity = escape_vel(mass,equatorial_radius);
     return((3.0 * pow(GAS_RETENTION_THRESHOLD * CM_PER_METER, 2.0) * MOLAR_GAS_CONST * EARTH_EXOSPHERE_TEMP) / pow(escape_velocity, 2.0));
}


/*--------------------------------------------------------------------------*/
/*   This function calculates the surface acceleration of a planet.  The    */
/*  mass is in units of solar masses, the radius in terms of km, and the    */
/*  acceleration is returned in units of cm/sec2.                           */
/*--------------------------------------------------------------------------*/

double acceleration(mass, radius)
double mass, radius;
{
     return(GRAV_CONSTANT * (mass * SOLAR_MASS_IN_GRAMS) / pow(radius * CM_PER_KM, 2.0));
}


/*--------------------------------------------------------------------------*/
/*   This function calculates the surface gravity of a planet.  The         */
/*  acceleration is in units of cm/sec2, and the gravity is returned in     */
/*  units of Earth gravities.                                               */
/*--------------------------------------------------------------------------*/

double gravity(acceleration)
double acceleration;
{
     return(acceleration / EARTH_ACCELERATION);
}


/*--------------------------------------------------------------------------*/
/*  Note that if the orbital radius of the planet is greater than or equal  */
/*  to R_inner, 99% of it's volatiles are assumed to have been deposited in */
/*  surface reservoirs (otherwise, it suffers from the greenhouse effect).  */
/*--------------------------------------------------------------------------*/

int greenhouse(zone, orbital_radius, greenhouse_radius)
int zone;
double orbital_radius, greenhouse_radius;
{
     if ((orbital_radius < greenhouse_radius) && (zone == 1))
          return(TRUE);
     else
          return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*  This implements Fogg's eq.17.  The 'inventory' returned is unitless.    */
/*--------------------------------------------------------------------------*/

double vol_inventory(mass, escape_vel, rms_vel, stellar_mass, zone, greenhouse_effect)
double mass, escape_vel, rms_vel, stellar_mass;
int zone, greenhouse_effect;
{
     double velocity_ratio, proportion_const, temp1, temp2, mass_in_earth_units;
     
     velocity_ratio = escape_vel / rms_vel;
     if (velocity_ratio >= GAS_RETENTION_THRESHOLD)
     {
          switch (zone) {
               case 1:
                    proportion_const = 100000.0;
                    break;
               case 2:
                    proportion_const = 75000.0;
                    break;
               case 3:
                    proportion_const = 250.0;
                    break;
               default:
                    printf("Error: orbital zone not initialized correctly!\n");
                    break;
               }
          mass_in_earth_units = mass * EARTH_MASSES_PER_SOLAR_MASS;
          temp1 = (proportion_const * mass_in_earth_units) / stellar_mass;
          temp2 = about(temp1,0.2);
          if (greenhouse_effect)
               return(temp2);
          else
               return(temp2 / 100.0);
     }
     else
          return(0.0);
}


/*--------------------------------------------------------------------------*/
/*  This implements Fogg's eq.18.  The pressure returned is in units of     */
/*  millibars (mb).  The gravity is in units of Earth gravities, the radius */
/*  in units of kilometers.                                                 */
/*--------------------------------------------------------------------------*/

double pressure(volatile_gas_inventory, equatorial_radius, gravity)
double volatile_gas_inventory, equatorial_radius, gravity;
{
     equatorial_radius = EARTH_RADIUS_IN_KM / equatorial_radius;
     return(volatile_gas_inventory * gravity / pow(equatorial_radius, 2.0));
}

/*--------------------------------------------------------------------------*/
/*   This function returns the boiling point of water in an atmosphere of   */
/*   pressure 'surface_pressure', given in millibars.  The boiling point is */
/*   returned in units of Kelvin.  This is Fogg's eq.21.                    */
/*--------------------------------------------------------------------------*/

double boiling_point(surface_pressure)
double surface_pressure;
{
     double surface_pressure_in_bars;
     
     surface_pressure_in_bars = surface_pressure / MILLIBARS_PER_BAR;
     return(1.0 / (log(surface_pressure_in_bars) / -5050.5 + 1.0 / 373.0));
}


/*--------------------------------------------------------------------------*/
/*   This function is Fogg's eq.22.  Given the volatile gas inventory and   */
/*   planetary radius of a planet (in Km), this function returns the        */
/*   fraction of the planet covered with water.                             */
/*   I have changed the function very slightly:  the fraction of Earth's    */
/*   surface covered by water is 71%, not 75% as Fogg used.                 */
/*--------------------------------------------------------------------------*/

double hydrosphere_fraction(volatile_gas_inventory, planetary_radius)
double volatile_gas_inventory, planetary_radius;
{
     double temp;
     
     temp = (0.71 * volatile_gas_inventory / 1000.0) * pow(EARTH_RADIUS_IN_KM / planetary_radius, 2.0);
     if (temp >= 1.0)
          return(1.0);
     else
          return(temp);
}


/*--------------------------------------------------------------------------*/
/*   Given the surface temperature of a planet (in Kelvin), this function   */
/*   returns the fraction of cloud cover available.  This is Fogg's eq.23.  */
/*   See Hart in "Icarus" (vol 33, pp23 - 39, 1978) for an explanation.     */
/*   This equation is Hart's eq.3.                                          */
/*   I have modified it slightly using constants and relationships from     */
/*   Glass's book "Introduction to Planetary Geology", p.46.                */
/*   The 'CLOUD_COVERAGE_FACTOR' is the amount of surface area on Earth     */
/*   covered by one Kg. of cloud.                                            */
/*--------------------------------------------------------------------------*/

double cloud_fraction(surface_temp, smallest_MW_retained, equatorial_radius, hydrosphere_fraction)
double surface_temp, smallest_MW_retained, equatorial_radius,
     hydrosphere_fraction;
{
     double water_vapor_in_kg, fraction, surface_area, hydrosphere_mass;
     
     if (smallest_MW_retained > WATER_VAPOR)
          return(0.0);
     else
     {
          surface_area = 4.0 * PI * pow(equatorial_radius, 2.0);
          hydrosphere_mass = hydrosphere_fraction * surface_area * EARTH_WATER_MASS_PER_AREA;
          water_vapor_in_kg = (0.00000001 * hydrosphere_mass) * exp(Q2_36 * (surface_temp - 288.0));
          fraction = CLOUD_COVERAGE_FACTOR * water_vapor_in_kg / surface_area;
          if (fraction >= 1.0)
               return(1.0);
          else
               return(fraction);
     }
}


/*--------------------------------------------------------------------------*/
/*   Given the surface temperature of a planet (in Kelvin), this function   */
/*   returns the fraction of the planet's surface covered by ice.  This is  */
/*   Fogg's eq.24.  See Hart[24] in Icarus vol.33, p.28 for an explanation. */
/*   I have changed a constant from 70 to 90 in order to bring it more in   */
/*   line with the fraction of the Earth's surface covered with ice, which  */
/*   is approximatly .016 (=1.6%).                                          */
/*--------------------------------------------------------------------------*/

double ice_fraction(hydrosphere_fraction, surface_temp)
double hydrosphere_fraction, surface_temp;
{
     double temp;
     
     if (surface_temp > 328.0)
          surface_temp = 328.0;
     temp = pow(((328.0 - surface_temp) / 90.0),5.0);
     if (temp > (1.5 * hydrosphere_fraction))
          temp = (1.5 * hydrosphere_fraction);
     if (temp >= 1.0)
          return(1.0);
     else
          return(temp);
}


/*--------------------------------------------------------------------------*/
/*  This is Fogg's eq.19.  The ecosphere radius is given in AU, the orbital */
/*  radius in AU, and the temperature returned is in Kelvin.                    */
/*--------------------------------------------------------------------------*/

double eff_temp(ecosphere_radius, orbital_radius, albedo)
double ecosphere_radius, orbital_radius, albedo;
{
     return(sqrt(ecosphere_radius / orbital_radius) * pow((1.0 - albedo) / 0.7,0.25) * EARTH_EFFECTIVE_TEMP);
}


/*--------------------------------------------------------------------------*/
/*  This is Fogg's eq.20, and is also Hart's eq.20 in his "Evolution of     */
/*  Earth's Atmosphere" article.  The effective temperature given is in     */
/*  units of Kelvin, as is the rise in temperature produced by the          */
/*  greenhouse effect, which is returned.                                   */
/*--------------------------------------------------------------------------*/

double green_rise(optical_depth, effective_temp, surface_pressure)
double optical_depth, effective_temp, surface_pressure;
{
     double convection_factor;
     
     convection_factor = EARTH_CONVECTION_FACTOR * pow((surface_pressure / EARTH_SURF_PRES_IN_MILLIBARS),0.25);
     return(pow((1.0 + 0.75 * optical_depth),0.25) - 1.0) * effective_temp * convection_factor;
}


/*--------------------------------------------------------------------------*/
/*   The surface temperature passed in is in units of Kelvin.               */
/*   The cloud adjustment is the fraction of cloud cover obscuring each     */
/*   of the three major components of albedo that lie below the clouds.     */
/*--------------------------------------------------------------------------*/

double planet_albedo(water_fraction, cloud_fraction, ice_fraction, surface_pressure)
double water_fraction, cloud_fraction, ice_fraction, surface_pressure;
{
     double rock_fraction, cloud_adjustment, components, cloud_contribution,
     rock_contribution, water_contribution, ice_contribution;
     
     rock_fraction = 1.0 - water_fraction - ice_fraction;
     components = 0.0;
     if (water_fraction > 0.0)
          components = components + 1.0;
     if (ice_fraction > 0.0)
          components = components + 1.0;
     if (rock_fraction > 0.0)
          components = components + 1.0;
     cloud_adjustment = cloud_fraction / components;
     if (rock_fraction >= cloud_adjustment)
          rock_fraction = rock_fraction - cloud_adjustment;
     else
          rock_fraction = 0.0;
     if (water_fraction > cloud_adjustment)
          water_fraction = water_fraction - cloud_adjustment;
     else
          water_fraction = 0.0;
     if (ice_fraction > cloud_adjustment)
          ice_fraction = ice_fraction - cloud_adjustment;
     else
          ice_fraction = 0.0;
     cloud_contribution = cloud_fraction * about(CLOUD_ALBEDO,0.2);
     if (surface_pressure == 0.0)
          rock_contribution = rock_fraction * about(AIRLESS_ROCKY_ALBEDO,0.3);
     else
          rock_contribution = rock_fraction * about(ROCKY_ALBEDO,0.1);
     water_contribution = water_fraction * about(WATER_ALBEDO,0.2);
     if (surface_pressure == 0.0)
          ice_contribution = ice_fraction * about(AIRLESS_ICE_ALBEDO,0.4);
     else
          ice_contribution = ice_fraction * about(ICE_ALBEDO,0.1);
     return(cloud_contribution + rock_contribution + water_contribution + ice_contribution);
}


/*--------------------------------------------------------------------------*/
/*   This function returns the dimensionless quantity of optical depth,     */
/*   which is useful in determining the amount of greenhouse effect on a    */
/*   planet.                                                                */
/*--------------------------------------------------------------------------*/

double opacity(molecular_weight, surface_pressure)
double molecular_weight, surface_pressure;
{
     double optical_depth;
     
     optical_depth = 0.0;
     if ((molecular_weight >= 0.0) && (molecular_weight < 10.0))
          optical_depth = optical_depth + 3.0;
     if ((molecular_weight >= 10.0) && (molecular_weight < 20.0))
          optical_depth = optical_depth + 2.34
